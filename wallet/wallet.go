package wallet

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"golang.org/x/crypto/ripemd160"
	"log"
)

const (
	checksumLength = 4
	version        = byte(0x00) //Hex representation of zero
)

type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

/*
Creates new pair of Private and Public keys for a new Wallet
@returns ecdsa.PrivateKey -> Private key of the wallet
@returns []byte -> slice of bytes which represents the PublicKey
*/
func NewKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256() //Outputs of this elliptic curve are 256 bits

	private, err := ecdsa.GenerateKey(curve, rand.Reader) //Generate private key

	if err != nil {
		log.Panicln(err)
	}

	//Public key is generated by Elliptic curve multiplication:
	//It is generated by retrieving random X and Y values of the curve and appending them as bytes
	pub := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...) // the '...' syntax makes us of the verafic symbol. In this case we are exploding the value of Y so that it can be concatenated with X creating one single value which is the public key.

	return *private, pub
}

/*
Creates a new Wallet

@returns pointer to the new Wallet
*/
func MakeWallet() *Wallet {
	private, public := NewKeyPair()

	wallet := Wallet{private, public}

	return &wallet
}

/*
Generates the public key hash which will be used to create the Address of the Private Key

@param pubKey: slice of bytes which is the public key
@returns: slice of bytes which is the public key hash obtained by hashing the public key with SHA256 and ripemd160
*/
func PublicKeyHash(pubKey []byte) []byte {
	pubHash := sha256.Sum256(pubKey)

	hasher := ripemd160.New()
	_, err := hasher.Write(pubHash[:])

	if err != nil {
		log.Panic(err)
	}

	//To actually get the hash we need to call Sum of ripemd160
	publicRipMD := hasher.Sum(nil) //nil because we don't want to concatenate anything to the already hashed digest

	return publicRipMD
}

/*
Calculates the checksum given the PublicKeyHash

@param payload: []byte which is the public key hash
@returns checksum ([]byte)
*/
func Checksum(payload []byte) []byte {
	firstHash := sha256.Sum256(payload)
	secondHash := sha256.Sum256(firstHash[:])

	return secondHash[:checksumLength] //returning first n bytes depending on checksum length (usually 4 bytes)
}

/*
Creates the Address of a Wallet
*/
func (w Wallet) Address() []byte {
	pubHash := PublicKeyHash(w.PublicKey)

	versionedHash := append([]byte{version}, pubHash...) //concatenating version with the public key hash

	checksum := Checksum(versionedHash)

	fullHash := append(versionedHash, checksum...)

	address := Base58Encode(fullHash)

	//fmt.Printf("NEW WALLET:\n")
	//fmt.Printf("Public key: %x\n", w.PublicKey)
	//fmt.Printf("Public key hash: %x\n", pubHash)
	//fmt.Printf("Address created: %s\n", address)

	return address
}
